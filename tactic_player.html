<!doctype html>
<html>
<head>
    <title>Tactic player</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="icon" type="image/png" href="img/chesspieces/wikipedia/wB.png">
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css" integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU" crossorigin="anonymous">

    <style>
        a:link, a:hover, a:visited, a:active {
           text-decoration: none;
        }

        .column {
            float: left;
            width: 50%;
        }

        .row:after {
            content: "";
            display: table;
            clear: both;
        }

        input {
            font-size: 10px;
        }

        .puzzles {
            display: inline-block;
        }

        @media screen and (orientation: portrait) {
            .column {
                width: 100%;
            }
        }
    </style>
</head>

<body>
<div class="row">
    <div class="column" style="min-width: 450px">
        <div><h3>Board</h3></div>
        <div>
            <table>
                <tr><td><input id="hide_first_move" type="checkbox" checked><label for="hide_first_move">Hide the first move?</label></td></tr>
                <tr><td><input id="keep_playing" type="checkbox" checked><label for="keep_playing">Keep playing random puzzles?</label></td></tr>
            </table>
        </div>
        <p></p>
        <div id="myBoard" style="margin: 0 auto; width: 400px"></div>
        <div id="buttons" style="display: inline-block; text-align: center; display: block">
            <button id="backward" type="button">&#9664;</button>
            <button id="reset" type="button">Reset puzzle</button>
            <button id="hint" type="button">Hint</button>
            <button id="solution" type="button">Solution</button>
            <button id="copyFEN" type="button">Copy FEN</button>
            <button id="copyPGN" type="button">Copy PGN</button>
            <button id="forward" type="button">&#9654;</button>
        </div>

        <div id="panel">&nbsp</div>
        <div id="status"></div>
        <div id="moveHistory"></div>
    </div>
    <div class="column" style="height: 100%; overflow: auto; font-size: 10px;">
        <h2><a href="javascript: refresh()">&#10227;</a> Games</h2>
        <p>All <code>checkmate</code> and <code>mating net</code> puzzles require to find the shortest route. Sometimes, there may be more one way to checkmate but only one should be the shortest. Unfortunately, in some cases Stockfish misevaluated the checkmate counters in a puzzle, yielding a puzzle that is not well posed.</p>
        <div class="row">
            <div><p>Select puzzle options:</p>
                <div class="column">Theme:
                    <div>
                        <div><input id="checkmate" class="theme" type="checkbox" checked><label for="checkmate">checkmate</label></div>
                        <div><input id="mating_net" class="theme" type="checkbox" checked><label for="mating_net">mating net</label></div>
                        <div><input id="material_advantage" class="theme" type="checkbox" checked><label for="material_advantage">material advantage</label></div>
                        <div><input id="repetition" class="theme" type="checkbox" checked><label for="repetition">repetition</label></div>
                        <div><input id="stalemate" class="theme" type="checkbox" checked><label for="stalemate">stalemate</label></div>
                    </div>
                </div>
                <div class="column">
                    <div><input id="unsolved" class="options" type="checkbox" checked><label for="unsolved">Only unsolved?</label></div>
                    <table>
                        <tr>
                            <td><label for="min_moves">Minimum moves:</label></td>
                            <td><input type="number" class="options" id="min_moves" min="1" max="100" value="2"></td>
                        </tr>
                        <tr>
                            <td><label for="max_moves">Maximum moves:</label></td>
                            <td><input type="number" class="options" id="max_moves" min="1" max="100" value="100"></td>
                        </tr>
                        <tr>
                            <td><label for="min_hardness">Minimum hardness:</label></td>
                            <td><input type="number" class="options" id="min_hardness" min="0" max="1" step="0.05" value="0.0"></td>
                        </tr>
                        <tr>
                            <td><label for="max_hardness">Maximum hardness:</label></td>
                            <td><input type="number" class="options" id="max_hardness" min="0" max="1" step="0.05" value="1.0"></td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
        <div>
            <p>Attention! The <b>Hardness</b> parameter does not mean the degree of difficulty of the puzzle, but the frequency of situations in which all but one of the player's moves fails. Counterintuitively, more often than not, puzzles with higher level of <b>Hardness</b> are easier to solve, as there is a very limited number of ways to not lose in a given situation.</p>
            <p><b><span id="success_rate"></span></b></p>
            <div style="text-align: center"><p><button id="random">&#9654; Play a random puzzle</button></p></div>
            <div id="number_of_puzzles"><p>0 puzzles in total.</p></div>
            <div style="puzzles">
                <table id="puzzles" class="sortable" style="text-align: center; white-space: nowrap">
                    <thead>
                        <tr>
                            <th>Play</th>
                            <th>Solved?</th>
                            <th>White</th>
                            <th>Black</th>
                            <th>Date</th>
                            <th>Puzzle type</th>
                            <th>Moves</th>
                            <th>Hardness</th>
                            <th>Evaluation</th>
                        </tr>
                    </thead>
                    <tbody id="puzzleList"></tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script src="https://code.jquery.com/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js" integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.2/chess.js" integrity="sha384-s3XgLpvmHyscVpijnseAmye819Ee3yaGa8NxstkJVyA6nuDFjt59u1QvuEl/mecz" crossorigin="anonymous"></script>
<script src="https://unpkg.com/chess-pgn-parser/dist/parser.js"></script>
<script src="https://www.kryogenix.org/code/browser/sorttable/sorttable.js"></script>
<script src="js/tactic.js"></script>
<script src="js/main.js"></script>

<script>

board = Chessboard('myBoard')

const $status = $('#status')
const $moveHistory = $('#moveHistory')
const $panel = $('#panel')

$('#hide_first_move').on('click', function() {
    hideFirstMove = document.getElementById('hide_first_move').checked
})

$('#backward').on('click', function() {
    if (tactic !== null) {
        backward()
    }
})

$('#forward').on('click', function() {
    if (tactic !== null) {
        forward()
    }
})

$('#refresh').on('click', function() {
    refresh()
})

$('#reset').on('click', function() {
    setPanel()
    reset()
})

$('#hint').on('click', function() {
    if (tactic !== null) {
        if (!tactic.solved && tactic.nextMove != null) {
            move = game.move(tactic.nextMove)
            game.undo()
            setPanel('Hint: ' + getFullPieceName(move.piece))
            delay(() => {setPanel()})
        }
    }
})

$('#solution').on('click', function() {
    if (tactic !== null) {
        if (!tactic.solved && tactic.nextMove != null) {
            setPanel('Hint: ' + tactic.nextMove)
            delay(() => {setPanel()})
        }
    }
})

$('#copyFEN').on('click', function() {
    if (fen !== null) {
        navigator.clipboard.writeText(fen)
    }
})

$('#copyPGN').on('click', function() {
    if (fen !== pgn) {
        navigator.clipboard.writeText(pgn)
    }
})

$('.theme').change(function() {
    filterPuzzles(puzzles)
})

$('.options').change(function() {
    filterPuzzles(puzzles)
})

$('#random').on('click', function() {
    loadNextPuzzle()
})

function backward() {
    game.undo()
    tactic.backward()
    board.position(game.fen())
    updateStatus()
}

function updateNumberOfPuzzles(puzzles) {
    if (puzzles != null) {
        var numberOfPuzzles = Object.keys(puzzles).length
        var numberOfPuzzlesText = `${numberOfPuzzles} puzzles in total.`
        $('#number_of_puzzles').html(numberOfPuzzlesText)
    }
}

function calculateSuccessRate(progress) {
    var correct = 0
    var total = 0
    for (const [hash, success] of Object.entries(progress)) {
        total += 1
        if (success) {
            correct += 1
        }
    }

    return [correct, total, total > 0 ? correct / total : 0.0]
}

function loadProgress() {
    fetch(progressPath, {cache: 'no-cache'})
    .then(response => response.json())
    .then(json => {
        progress = json

        var [correct, total, rate] = calculateSuccessRate(progress)
        rate = parseFloat(100 * rate).toFixed(2)
        var successRateText = `Success rate: ${correct}/${total} (${rate}%).`
        $('#success_rate').html(successRateText)
    })
}

function loadPuzzles() {
    fetch(puzzlesPath)
    .then(response => response.json())
    .then(json => {
        puzzles = json
        filterPuzzles(json)
    })
}

function getSolvedSymbol(value) {
    if (value == null) {
        return ''
    }

    return value ? '✔' : '✘'
}

function getPuzzlePath(puzzle) {
    return puzzle.path.replace(/[\\/]+/g, '/').replace(/^([a-zA-Z]+:|\.\/)/, '')
}

function gatherPuzzleTypes() {
    var puzzleTypes = []
    for (const element of $('.theme')) {
        if (element.checked) {
            var theme = element.id.replace('_', ' ')
            puzzleTypes.push(theme)
        }
    }

    return puzzleTypes
}

function filterPuzzles(puzzles) {
    if (puzzles == null) {
        return undefined
    }

    filteredPuzzles = []

    var puzzleTypes = gatherPuzzleTypes()
    var onlyUnsolved = document.getElementById('unsolved').checked
    var minMoves = $('#min_moves').val()
    var maxMoves = $('#max_moves').val()
    var minHardness = parseFloat($('#min_hardness').val())
    var maxHardness = parseFloat($('#max_hardness').val())

    for (const puzzle of puzzles) {
        var hardness = parseFloat(puzzle.hardness)
        if (
            puzzleTypes.includes(puzzle.puzzleType)
            && (!onlyUnsolved || !(puzzle.hash in progress))
            && puzzle.moves >= minMoves
            && puzzle.moves <= maxMoves
            && hardness >= minHardness
            && hardness <= maxHardness
        ) {
            filteredPuzzles.push(puzzle)
        }
    }

    createPuzzleTable(filteredPuzzles)
    updateNumberOfPuzzles(filteredPuzzles)
}

function clearPuzzleTable() {
    const node = document.getElementById('puzzleList')
    while (node.firstChild) {
        node.removeChild(node.lastChild)
    }
}

function createPuzzleTableRowEntry(tr, text, link, id) {
    var td = document.createElement('td')
    if (id != null) {
        td.id = id
    }

    var textNode = document.createTextNode(text)
    if (link != null) {
        var a = document.createElement('a')
        a.href = link
        a.appendChild(textNode)
        td.appendChild(a)
    } else {
        td.appendChild(textNode)
    }

    tr.appendChild(td)
}

function createPuzzleTable(puzzles) {
    clearPuzzleTable()
    const tableObject = document.getElementById('puzzleList')
    for (const puzzle of puzzles) {
        var tr = document.createElement('tr');

        var path = getPuzzlePath(puzzle)
        var link = `javascript:loadPGN('${path}', '${puzzle.hash}')`
        var solved = getSolvedSymbol(progress[puzzle.hash])
        var puzzleId = `puzzle${puzzle.hash}`

        createPuzzleTableRowEntry(tr, '▶', link)
        createPuzzleTableRowEntry(tr, solved, null, puzzleId)
        createPuzzleTableRowEntry(tr, puzzle.white)
        createPuzzleTableRowEntry(tr, puzzle.black)
        createPuzzleTableRowEntry(tr, puzzle.date)
        createPuzzleTableRowEntry(tr, puzzle.puzzleType)
        createPuzzleTableRowEntry(tr, puzzle.moves)
        createPuzzleTableRowEntry(tr, puzzle.hardness.toFixed(2))
        createPuzzleTableRowEntry(tr, puzzle.initialEvaluation)
        tableObject.appendChild(tr)
    }

    sorttable.makeSortable(document.getElementById('puzzles'))
}

function loadNextPuzzle() {
    filterPuzzles(puzzles)
    if (filteredPuzzles == null) {
        return
    } else if (!filteredPuzzles.length) {
        return
    }

    var puzzle = filteredPuzzles[(Math.floor(Math.random() * (filteredPuzzles.length)))]
    var path = getPuzzlePath(puzzle)
    loadPGN(path, puzzle.hash)
}

function updateSolvedStatus(currentPuzzleId, value) {
    var statusSymbol = getSolvedSymbol(value)
    var $element = $('#puzzle' + currentPuzzleId)
    if ($element != null && progress[currentPuzzleId] == null) {
        $element.html(statusSymbol)
    }
}

function refresh() {
    $.ajax({
        url: 'refresh',
        type: 'GET',
        success: () => {
            loadPuzzles()
            loadProgress()
        },
        error: () => {
            console.error('Unable to refresh puzzles')
        }
    })
}

panelTextCallback = setPanel
statusTextCallback = (text) => {$status.html(text)}
moveHistoryTextCallback = (text) => {$moveHistory.html(text)}
loadNextPuzzleCallback = loadNextPuzzle
progressCallback = updateSolvedStatus
refreshCallback = refresh

refresh()

</script>
</body>
</html>
