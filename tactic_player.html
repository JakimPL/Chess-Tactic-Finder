<!doctype html>
<html>
<head>
    <title>Tactic player</title>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no"/>

    <link rel="icon" type="image/png" href="img/chesspieces/wikipedia/wB.png">
    <link rel="stylesheet" href="css/style.css">
    <link rel="stylesheet" href="css/import/chessboard-1.0.0.min.css" integrity="sha384-q94+BZtLrkL1/ohfjR8c6L+A6qzNH9R2hBLwyoAfu3i/WCvQjzL2RQJ3uNHDISdU" crossorigin="anonymous">

    <script src="js/import/jquery-3.4.1.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
    <script src="js/import/chessboard-1.0.0.min.js" integrity="sha384-8Vi8VHwn3vjQ9eUHUxex3JSN/NFqUg3QbPyX8kWyb93+8AC/pPWTzj+nHtbC5bxD" crossorigin="anonymous"></script>
    <script src="js/import/chess.js" integrity="sha384-s3XgLpvmHyscVpijnseAmye819Ee3yaGa8NxstkJVyA6nuDFjt59u1QvuEl/mecz" crossorigin="anonymous"></script>
    <script src="js/import/parser.js"></script>
    <script src="js/import/sorttable.js"></script>
    <script src="js/tactic.js"></script>
    <script src="js/main.js"></script>
</head>

<body>
<div class="row">
    <div class="column" id="board_panel">
        <div><h3>Board</h3></div>
        <div>
            <table>
                <tr><td><input id="hide_first_move" type="checkbox"><label for="hide_first_move">Hide the first move?</label></td></tr>
                <tr><td><input id="keep_playing" type="checkbox" checked><label for="keep_playing">Keep playing random puzzles?</label></td></tr>
            </table>
        </div>
        <div><p><b><span id="success_rate">Success rate:</span></b></p></div>
        <div class="buttons">
            <button id="random">Play a random puzzle</button>
        </div>
        <div id="board"></div>
        <div class="buttons">
            <button id="backward" type="button">&#9664;</button>
            <button id="reset" type="button">Reset puzzle</button>
            <button id="hint" type="button">Hint</button>
            <button id="solution" type="button">Solution</button>
            <button id="forward" type="button">&#9654;</button>
        </div>
        <div class="buttons">
            <button id="copyFEN" type="button">Copy FEN</button>
            <button id="copyPGN" type="button">Copy PGN</button>
        </div>

        <div id="panel">&nbsp</div>
        <div id="status"></div>
        <div id="moveHistory"></div>
    </div>
    <div class="column" id="games_panel">
        <h2><a href="javascript: refresh()">&#10227;</a> Games</h2>
        <p>All <code>checkmate</code> and <code>mating net</code> puzzles require to find the shortest route. Sometimes, there may be more one way to checkmate but only one should be the shortest. Unfortunately, in some cases Stockfish misevaluated the checkmate counters in a puzzle, yielding a puzzle that is not well posed.</p>
        <div class="row">
            <div><h3>Puzzle options</h3>
                <div class="column"><h4>Theme</h4>
                    <div>
                        <div><input id="checkmate" class="theme" type="checkbox" checked><label for="checkmate">checkmate</label></div>
                        <div><input id="mating_net" class="theme" type="checkbox" checked><label for="mating_net">mating net</label></div>
                        <div><input id="material_advantage" class="theme" type="checkbox" checked><label for="material_advantage">material advantage</label></div>
                        <div><input id="repetition" class="theme" type="checkbox" checked><label for="repetition">repetition</label></div>
                        <div><input id="stalemate" class="theme" type="checkbox" checked><label for="stalemate">stalemate</label></div>
                    </div>
                </div>
                <div class="column"><h4>Other options</h4>
                    <table>
                        <tr>
                            <td><label for="unsolved">Only unsolved?</label></td>
                            <td><input id="unsolved" class="options" type="checkbox" checked></td>
                        </tr>
                        <tr>
                            <td><label for="min_moves">Minimum moves:</label></td>
                            <td><input type="number" class="options" id="min_moves" min="1" max="100" value="2"></td>
                        </tr>
                        <tr>
                            <td><label for="max_moves">Maximum moves:</label></td>
                            <td><input type="number" class="options" id="max_moves" min="1" max="100" value="100"></td>
                        </tr>
                        <tr>
                            <td><label for="min_hardness">Minimum hardness:</label></td>
                            <td><input type="number" class="options" id="min_hardness" min="0" max="1" step="0.05" value="0.0"></td>
                        </tr>
                        <tr>
                            <td><label for="max_hardness">Maximum hardness:</label></td>
                            <td><input type="number" class="options" id="max_hardness" min="0" max="1" step="0.05" value="1.0"></td>
                        </tr>
                    </table>
                </div>
            </div>
        </div>
        <div>
            <p>Attention! The <b>Hardness</b> parameter does not mean the degree of difficulty of the puzzle, but the frequency of situations in which all but one of the player's moves fails. Counterintuitively, more often than not, puzzles with higher level of <b>Hardness</b> are easier to solve, as there is a very limited number of ways to not lose in a given situation.</p>
            <div id="number_of_puzzles"><p>0 puzzles in total.</p></div>
            <div id="puzzlesList">
                <table id="puzzles" class="sortable">
                    <thead>
                        <tr>
                            <th>Play</th>
                            <th>Solved?</th>
                            <th>Color</th>
                            <th>White</th>
                            <th>Black</th>
                            <th>Date</th>
                            <th>Puzzle type</th>
                            <th>Moves</th>
                            <th>Hardness</th>
                            <th>Evaluation</th>
                        </tr>
                    </thead>
                    <tbody id="puzzleList"></tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<script>

configuration = loadConfiguration()
board = Chessboard('board')

const $status = $('#status')
const $moveHistory = $('#moveHistory')
const $panel = $('#panel')

var progressLoaded = $.Deferred()
var puzzlesLoaded = $.Deferred()

$.when(progressLoaded, puzzlesLoaded).done(function() {
    updateSuccessRate()
    updateSolvedStates()
    loadNextPuzzle()
})

$('#hide_first_move').on('click', function() {
    hideFirstMove = document.getElementById('hide_first_move').checked
})

$('#backward').on('click', function() {
    if (tactic !== null) {
        backward()
    }
})

$('#forward').on('click', function() {
    if (tactic !== null) {
        forward()
    }
})

$('#refresh').on('click', function() {
    refresh()
})

$('#reset').on('click', function() {
    setPanel()
    reset()
})

$('#hint').on('click', function() {
    if (tactic !== null) {
        if (!tactic.solved && tactic.nextMove != null) {
            move = game.move(tactic.nextMove)
            game.undo()
            setPanel('Hint: ' + getFullPieceName(move.piece))
            delay(() => {setPanel()})
        }
    }
})

$('#solution').on('click', function() {
    if (tactic !== null) {
        if (!tactic.solved && tactic.nextMove != null) {
            setPanel('Hint: ' + tactic.nextMove)
            delay(() => {setPanel()})
        }
    }
})

$('#copyFEN').on('click', function() {
    if (fen !== null) {
        navigator.clipboard.writeText(fen)
        setPanel('FEN copied to clipboard!')
    }
})

$('#copyPGN').on('click', function() {
    if (fen !== pgn) {
        navigator.clipboard.writeText(pgn)
        setPanel('PGN copied to clipboard!')
    }
})

$('.theme').change(function() {
    filterPuzzles(puzzles)
})

$('.options').change(function() {
    filterPuzzles(puzzles)
})

$('#random').on('click', function() {
    markButton('random')
    delay(loadNextPuzzle, 50)
})

function markButton(button) {
    document.getElementById(button).style.backgroundColor = '#b58863'
}

function unmarkButton(button) {
    document.getElementById(button).style.backgroundColor = '#f0d9b5'
}

function updateNumberOfPuzzles(puzzles) {
    if (puzzles != null) {
        var numberOfPuzzles = Object.keys(puzzles).length
        var numberOfPuzzlesText = `${numberOfPuzzles} puzzles in total.`
        $('#number_of_puzzles').html(numberOfPuzzlesText)
    }
}

function updateSuccessRate() {
    var [correct, total, rate] = calculateSuccessRate(progress)
    rate = parseFloat(100 * rate).toFixed(2)
    var successRateText = `Success rate: ${correct}/${total} (${rate}%).`
    $('#success_rate').html(successRateText)
}

function updateSolvedStatus(hash, value, moves) {
    var statusSymbol = getSolvedSymbol(value, moves)
    var puzzleId = `puzzle${hash}`
    var element = document.getElementById(puzzleId)
    if (element != null && value != null) {
        element.innerHTML = statusSymbol
        element.style.color = value >= moves ? 'green' : 'red'
        element.style.fontWeight = 'bold'
    }
}

function updateSolvedStates() {
    for (const hash in progress) {
        var value = progress[hash]
        var index = hashes[hash]
        if (index in puzzles) {
            var moves = puzzles[index].moves
            updateSolvedStatus(hash, value, moves)
        }
    }
}

function loadConfiguration() {
    fetch('configuration.json', {cache: 'no-cache'})
    .then(response => response.json())
    .then(json => {
        configuration = json
        progressPath = configuration['paths']['progress']
        puzzlesPath = configuration['paths']['gathered_puzzles']
        hardEvaluation = !configuration['tactic_player']['count_moves_instead_of_puzzles']
        useLocalStorage = configuration['tactic_player']['use_local_storage']
    })
}

function loadProgress() {
    if (useLocalStorage) {
        if ('progress' in localStorage) {
            progress = JSON.parse(localStorage.getItem('progress'))
        } else {
            progress = {}
            localStorage.setItem('progress', JSON.stringify(progress))
        }

        progressLoaded.resolve()
    } else {
        fetch(progressPath, {cache: 'no-cache'})
        .then(response => response.json())
        .then(json => {
            progress = json
            progressLoaded.resolve()
        })
    }
}

function loadPuzzles() {
    fetch(puzzlesPath)
    .then(response => response.json())
    .then(json => {
        puzzles = json
        filterPuzzles(puzzles)

        for (var i = 0; i < puzzles.length; i++) {
            var puzzle = puzzles[i]
            hashes[puzzle.hash] = i
        }

        puzzlesLoaded.resolve()
    })
}

function getSolvedSymbol(value, moves) {
    if (value == null) {
        return ''
    }

    return `${value}/${moves}`
    // return value >= moves ? '✔' : '✘'
}

function gatherPuzzleTypes() {
    var puzzleTypes = []
    for (const element of $('.theme')) {
        if (element.checked) {
            var theme = element.id.replace('_', ' ')
            puzzleTypes.push(theme)
        }
    }

    return puzzleTypes
}

function filterPuzzles(puzzles) {
    if (puzzles == null) {
        return undefined
    }

    filteredPuzzles = []

    var puzzleTypes = gatherPuzzleTypes()
    var onlyUnsolved = document.getElementById('unsolved').checked
    var minMoves = $('#min_moves').val()
    var maxMoves = $('#max_moves').val()
    var minHardness = parseFloat($('#min_hardness').val())
    var maxHardness = parseFloat($('#max_hardness').val())

    for (const puzzle of puzzles) {
        var hardness = parseFloat(puzzle.hardness)
        if (
            puzzleTypes.includes(puzzle.puzzleType)
            && (!onlyUnsolved || !(puzzle.hash in progress))
            && puzzle.moves >= minMoves
            && puzzle.moves <= maxMoves
            && hardness >= minHardness
            && hardness <= maxHardness
        ) {
            filteredPuzzles.push(puzzle)
        }
    }

    createPuzzleTable(filteredPuzzles)
    updateNumberOfPuzzles(filteredPuzzles)
    updateSolvedStates()
}

function clearPuzzleTable() {
    const node = document.getElementById('puzzleList')
    while (node.firstChild) {
        node.removeChild(node.lastChild)
    }
}

function createPuzzleTableRowEntry(tr, text, link, id) {
    var td = document.createElement('td')
    if (id != null) {
        td.id = id
    }

    var textNode = document.createTextNode(text)
    if (link != null) {
        var a = document.createElement('a')
        a.href = link
        a.appendChild(textNode)
        td.appendChild(a)
    } else {
        td.appendChild(textNode)
    }

    tr.appendChild(td)
}

function createPuzzleTable(puzzles) {
    clearPuzzleTable()
    const tableObject = document.getElementById('puzzleList')
    for (const puzzle of puzzles) {
        var tr = document.createElement('tr')

        var path = getPuzzlePath(puzzle)
        var link = `javascript:loadPGN('${path}', '${puzzle.hash}')`
        var solved = getSolvedSymbol(progress[puzzle.hash], puzzle.moves)
        var puzzleId = `puzzle${puzzle.hash}`

        createPuzzleTableRowEntry(tr, '▶', link)
        createPuzzleTableRowEntry(tr, solved, null, puzzleId)
        createPuzzleTableRowEntry(tr, puzzle.whiteToMove ? '◉' : '○')
        createPuzzleTableRowEntry(tr, puzzle.white)
        createPuzzleTableRowEntry(tr, puzzle.black)
        createPuzzleTableRowEntry(tr, puzzle.date)
        createPuzzleTableRowEntry(tr, puzzle.puzzleType)
        createPuzzleTableRowEntry(tr, puzzle.moves)
        createPuzzleTableRowEntry(tr, puzzle.hardness.toFixed(2))
        createPuzzleTableRowEntry(tr, puzzle.initialEvaluation)
        tableObject.appendChild(tr)
    }

    sorttable.makeSortable(document.getElementById('puzzles'))
}

panelTextCallback = setPanel
statusTextCallback = (text) => {$status.html(text)}
moveHistoryTextCallback = (text) => {$moveHistory.html(text)}
progressCallback = updateSolvedStatus
loadPuzzlesCallback = loadPuzzles
loadProgressCallback = loadProgress
updateSuccessRateCallback = updateSuccessRate

afterLoadCallback = () => {unmarkButton('random')}
beforeLoadCallback = () => {markButton('random')}

hideFirstMove = document.getElementById('hide_first_move').checked
keepPlaying = document.getElementById('keep_playing').checked
markButton('random')

refresh()
</script>

</body>
</html>
